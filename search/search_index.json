{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Get your game data with speed. River is a fast and simple ECS made specifically with data in mind. Make your games faster and easier to manage. It has a simple syntax and lets you use Luau type system. River gets your data right when you want it. It's reactive and can plug into any framework. River can query over 1 million entities in milliseconds! Github Get Started Api Simple syntax River is easy to learn, so you don't have to worry about the implementation. It makes you use the best standards and lets you use the data how you want. local MyComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) local MyEntity = Entity ( MyComponent ({ Name = \"Dave\" , Age = 69 , })) Easily change your data River makes it easy to mutate your data and lets you get the data you want. local Position = Component ( Type ( \"Vector3\" )) local updateposition = System ( function ( entities ) for _ , entity in pairs ( entities ) do entity . Position += Vector3 . new ( 0 , 1 , 0 ) end end ) updateposition : add ( Query ( Positon )) Run when you want Never worry about race conditions again. You can let River handle the calling or do it yourself. updateposition : call () -- Or local world = World () world : add ( updateposition , \"update\" ) world : start () Are you ready? Read how to Get Started with River here!","title":"Home"},{"location":"#are-you-ready","text":"Read how to Get Started with River here!","title":"Are you ready?"},{"location":"Api/","text":"River Houses all the components of River. Contains: Component Entity System Query Tag Type World Pools Internal: Scheduler Component Component is the way you define how data should look. The data is defined using Types . Constructor River::Component(comp: { [string | number]: Type } | Type) -> Component Create a new component. local Component = River . Component local Type = River . Type Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) -- OR Component ( Type ( \"Vector3\" )) Call Component(value: { [string | number]: any } | any, typecheck: boolean) -> { [string | number] } Typechecks the value and returns it as a ComponentValue. local Component = River . Component local Type = River . Type local MyComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) MyComponent ({ Name = \"John\" , Age = 42 , }) Entity Entity is the way to create data. Use Component Values to define how data should look. Constructor River::Entity(tab: { [string | number]: Queryable }) -> number Takes a list of either Component Values , or Tags and returns the id of the entity. The data passed to the Entity constructor MUST be a list. local Type = River . Type local Component = River . Component local Entity = River . Entity local MyComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) local MyEntity = Entity ({ Person = MyComponent ({ Name = \"John\" , Age = 42 , }), }) Query Queries is the way to get entities. Use Components and Tags specify them. Constructor River::Query(toquery: {[string | number]: Queryable} | Queryable) -> Query Takes a list or a single Component or Tag and creates a Query. local Component = River . Component local Entity = River . Entity local Query = River . Query local MyComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) -- Create your entities, or later... local MyQuery = Query ( MyComponent ) -- OR local MyQuery = Query ({ Person = MyComponent }) Get Query:get(update: boolean) -> any Returns the list of entities the Query has gotten. If update is true, then it will force update the list. local Query = River . Query -- Create your entities local MyQuery = Query (...) local MyEntities = MyQuery : get () -- FORCE UPDATE local MyEntities = MyQuery : get ( true ) System Systems is the way to change data on your entities. Use Queries to find entities. Constructor River::System(func: (...Query) -> nil) -> System Takes a function that takes a vararg of Queries and creates a System. local System = River . System local MySystem = System ( function ( query1 , query2 , ...) -- Do stuff -- NOTE: We havent added the queried yet! end ) Add System:add(query: Query) -> System Takes a Query and adds it to the System, the system function will be called with it. local System = River . System local Query = River . Query local MyQuery = Query (...) local MySystem = System ( function ( query ) -- Do stuff with MyQuery end ) MySystem : add ( MyQuery ) Call System:call() Calls the system. Danger The function is ran synchronously, and does NOT have any error handling. Consider using Promise. Tag Tag is a way to easily specify a list of entities. Constructor River::Tag(name: string): Tag Takes a string and creates a Tag. local Tag = River . Tag local Entity = River . Entity local Query = River . Query local MyTag = Tag ( \"MyTag\" ) local MyEntity = Entity ({ MyTag = MyTag , }) local MyQuery = Query ( MyTag ) -- OR local MyQuery = Query ({ MyTag = MyTag }) Type Type is the way to define what the data is. Used in Components . Constructor River::Type(name: string) -> Type local Component = River . Component local Type = River . Type local MyComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) Call Type(value: any) -> boolean Takes a value and returns wether or not it is of the type. local Type = River . Type local MyStringType = Type ( \"string\" ) print ( MyStringType ( \"Hello\" )) -> true print ( MyStringType ( 42 )) -> false List of Types Heres a list of all the types currently available: (Open an issue if you want to add one) string number boolean table vector CFrame Vector3 Vector2 UDim UDim2 Instance Color3 EnumItem Enum function any Component Entity System Query Tag Type World Worlds are a way to organize your Systems . Constructor River::World() -> World Creates a new World. local World = River . World local MyWorld = World () Add World:add(system: System, whentocall: string?) Takes a system and when to call it ( start , update and stop ) and adds it to the World. local World = River . World -- Create your system local MyWorld = World () MyWorld : add ( MySystem , \"start\" ) -- Will be ran on start MyWorld : add ( MySystem , \"update\" ) -- Will be ran every frame MyWorld : add ( MySystem , \"stop\" ) -- Will be ran on stop -- NOTE: The world isnt started yet! Start World:start() Calls all Systems bound to start and adds the world to the updater. The updater will call all systems bound to update on every render step. local World = River . World -- Create your system local MyWorld = World () MyWorld : add ( MySystem , \"start\" ) MyWorld : start () Stop World:stop() Calls all Systems bound to stop and removes the world from the updater. The updater will call all systems bound to update on every render step. local World = River . World -- Create your system local MyWorld = World () MyWorld : add ( MySystem , \"stop\" ) MyWorld : stop () Pools Pools is the place where River stores all its data. The pools are broken into smaller internal pools: Component Entity Query Tag Internal pools have a property called data , where ids are mapped to values. Internal Pools is used internally, and should be used with caution. local Pools = River . Pools local Entity = River . Entity -- Create a component local MyEntityID = Entity ({ Person = MyComponent }) -- NOTE: Entity is not cleaned! local MyEntity = Pools . Entity . data [ MyEntityID ] Internal - Scheduler The scheduler is used to get data and handle internal stuff in River. However, you can use it to do stuff. (See source code) Internal Scheduler is used internally, and should be used with caution.","title":"Api"},{"location":"Api/#river","text":"Houses all the components of River. Contains: Component Entity System Query Tag Type World Pools Internal: Scheduler","title":"River"},{"location":"Api/#component","text":"Component is the way you define how data should look. The data is defined using Types .","title":"Component"},{"location":"Api/#constructor","text":"River::Component(comp: { [string | number]: Type } | Type) -> Component Create a new component. local Component = River . Component local Type = River . Type Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) -- OR Component ( Type ( \"Vector3\" ))","title":"Constructor"},{"location":"Api/#call","text":"Component(value: { [string | number]: any } | any, typecheck: boolean) -> { [string | number] } Typechecks the value and returns it as a ComponentValue. local Component = River . Component local Type = River . Type local MyComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) MyComponent ({ Name = \"John\" , Age = 42 , })","title":"Call"},{"location":"Api/#entity","text":"Entity is the way to create data. Use Component Values to define how data should look.","title":"Entity"},{"location":"Api/#constructor_1","text":"River::Entity(tab: { [string | number]: Queryable }) -> number Takes a list of either Component Values , or Tags and returns the id of the entity. The data passed to the Entity constructor MUST be a list. local Type = River . Type local Component = River . Component local Entity = River . Entity local MyComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) local MyEntity = Entity ({ Person = MyComponent ({ Name = \"John\" , Age = 42 , }), })","title":"Constructor"},{"location":"Api/#query","text":"Queries is the way to get entities. Use Components and Tags specify them.","title":"Query"},{"location":"Api/#constructor_2","text":"River::Query(toquery: {[string | number]: Queryable} | Queryable) -> Query Takes a list or a single Component or Tag and creates a Query. local Component = River . Component local Entity = River . Entity local Query = River . Query local MyComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) -- Create your entities, or later... local MyQuery = Query ( MyComponent ) -- OR local MyQuery = Query ({ Person = MyComponent })","title":"Constructor"},{"location":"Api/#get","text":"Query:get(update: boolean) -> any Returns the list of entities the Query has gotten. If update is true, then it will force update the list. local Query = River . Query -- Create your entities local MyQuery = Query (...) local MyEntities = MyQuery : get () -- FORCE UPDATE local MyEntities = MyQuery : get ( true )","title":"Get"},{"location":"Api/#system","text":"Systems is the way to change data on your entities. Use Queries to find entities.","title":"System"},{"location":"Api/#constructor_3","text":"River::System(func: (...Query) -> nil) -> System Takes a function that takes a vararg of Queries and creates a System. local System = River . System local MySystem = System ( function ( query1 , query2 , ...) -- Do stuff -- NOTE: We havent added the queried yet! end )","title":"Constructor"},{"location":"Api/#add","text":"System:add(query: Query) -> System Takes a Query and adds it to the System, the system function will be called with it. local System = River . System local Query = River . Query local MyQuery = Query (...) local MySystem = System ( function ( query ) -- Do stuff with MyQuery end ) MySystem : add ( MyQuery )","title":"Add"},{"location":"Api/#call_1","text":"System:call() Calls the system. Danger The function is ran synchronously, and does NOT have any error handling. Consider using Promise.","title":"Call"},{"location":"Api/#tag","text":"Tag is a way to easily specify a list of entities.","title":"Tag"},{"location":"Api/#constructor_4","text":"River::Tag(name: string): Tag Takes a string and creates a Tag. local Tag = River . Tag local Entity = River . Entity local Query = River . Query local MyTag = Tag ( \"MyTag\" ) local MyEntity = Entity ({ MyTag = MyTag , }) local MyQuery = Query ( MyTag ) -- OR local MyQuery = Query ({ MyTag = MyTag })","title":"Constructor"},{"location":"Api/#type","text":"Type is the way to define what the data is. Used in Components .","title":"Type"},{"location":"Api/#constructor_5","text":"River::Type(name: string) -> Type local Component = River . Component local Type = River . Type local MyComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), })","title":"Constructor"},{"location":"Api/#call_2","text":"Type(value: any) -> boolean Takes a value and returns wether or not it is of the type. local Type = River . Type local MyStringType = Type ( \"string\" ) print ( MyStringType ( \"Hello\" )) -> true print ( MyStringType ( 42 )) -> false","title":"Call"},{"location":"Api/#list-of-types","text":"Heres a list of all the types currently available: (Open an issue if you want to add one) string number boolean table vector CFrame Vector3 Vector2 UDim UDim2 Instance Color3 EnumItem Enum function any Component Entity System Query Tag Type","title":"List of Types"},{"location":"Api/#world","text":"Worlds are a way to organize your Systems .","title":"World"},{"location":"Api/#constructor_6","text":"River::World() -> World Creates a new World. local World = River . World local MyWorld = World ()","title":"Constructor"},{"location":"Api/#add_1","text":"World:add(system: System, whentocall: string?) Takes a system and when to call it ( start , update and stop ) and adds it to the World. local World = River . World -- Create your system local MyWorld = World () MyWorld : add ( MySystem , \"start\" ) -- Will be ran on start MyWorld : add ( MySystem , \"update\" ) -- Will be ran every frame MyWorld : add ( MySystem , \"stop\" ) -- Will be ran on stop -- NOTE: The world isnt started yet!","title":"Add"},{"location":"Api/#start","text":"World:start() Calls all Systems bound to start and adds the world to the updater. The updater will call all systems bound to update on every render step. local World = River . World -- Create your system local MyWorld = World () MyWorld : add ( MySystem , \"start\" ) MyWorld : start ()","title":"Start"},{"location":"Api/#stop","text":"World:stop() Calls all Systems bound to stop and removes the world from the updater. The updater will call all systems bound to update on every render step. local World = River . World -- Create your system local MyWorld = World () MyWorld : add ( MySystem , \"stop\" ) MyWorld : stop ()","title":"Stop"},{"location":"Api/#pools","text":"Pools is the place where River stores all its data. The pools are broken into smaller internal pools: Component Entity Query Tag Internal pools have a property called data , where ids are mapped to values. Internal Pools is used internally, and should be used with caution. local Pools = River . Pools local Entity = River . Entity -- Create a component local MyEntityID = Entity ({ Person = MyComponent }) -- NOTE: Entity is not cleaned! local MyEntity = Pools . Entity . data [ MyEntityID ]","title":"Pools"},{"location":"Api/#internal-scheduler","text":"The scheduler is used to get data and handle internal stuff in River. However, you can use it to do stuff. (See source code) Internal Scheduler is used internally, and should be used with caution.","title":"Internal - Scheduler"},{"location":"GetStarted/","text":"River River is a fast and easy ECS that is embeddable and lightweight. Using systems and queries, you can get millions of entities in milliseconds. With components, you can easily define the structure of your data. Installing There are multiple ways of installing. Pick the one that suits you best! Roblox Studio : Get the Module's rbx file from the GitHub Releases . Place the Module within ReplicatedStorage. Rojo workflow : Download River zip folder from the latest GitHub Releases . Extract the Folder from the zipped file. Point the Folder to Replicated Storage. Git workflow : Run git submodule add https://github.com/HawDevelopment/River.git Point the Submodule folder to ReplicatedStorage using Rojo. Wally workflow: Add express = \"hawdevelopment/river\" to your wally.toml","title":"Getting Started"},{"location":"GetStarted/#river","text":"River is a fast and easy ECS that is embeddable and lightweight. Using systems and queries, you can get millions of entities in milliseconds. With components, you can easily define the structure of your data.","title":"River"},{"location":"GetStarted/#installing","text":"There are multiple ways of installing. Pick the one that suits you best! Roblox Studio : Get the Module's rbx file from the GitHub Releases . Place the Module within ReplicatedStorage. Rojo workflow : Download River zip folder from the latest GitHub Releases . Extract the Folder from the zipped file. Point the Folder to Replicated Storage. Git workflow : Run git submodule add https://github.com/HawDevelopment/River.git Point the Submodule folder to ReplicatedStorage using Rojo. Wally workflow: Add express = \"hawdevelopment/river\" to your wally.toml","title":"Installing"},{"location":"GetStarted/Data/","text":"Defining and Creating Data In River theres only one way to create data, entities. Entities only create data, they dont define it. For defining data you will need to use Components. Lets get some examples going. Creating a Component Components are simply a single or a list of Types. Types are a way to define your the types of your data. Types can be any for of data, string , number , table , Vector3 , etc. local Type = River . Type local Component = River . Component -- Creating a single type local MyComponent = Component ( Type ( \"string\" )) -- Creating a list of types local MyListComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), }) Creating an Entity Components are just patters for creating data. With entities you can create data. local Entity = River . Entity local MyEntity = Entity ({ MyComponent = MyComponent ( \"Hello World\" ), MyListComponent = MyListComponent ({ Name = \"John\" , Age = 32 , }), }) And thats it! You can now define and create data!","title":"Data"},{"location":"GetStarted/Data/#defining-and-creating-data","text":"In River theres only one way to create data, entities. Entities only create data, they dont define it. For defining data you will need to use Components. Lets get some examples going.","title":"Defining and Creating Data"},{"location":"GetStarted/Data/#creating-a-component","text":"Components are simply a single or a list of Types. Types are a way to define your the types of your data. Types can be any for of data, string , number , table , Vector3 , etc. local Type = River . Type local Component = River . Component -- Creating a single type local MyComponent = Component ( Type ( \"string\" )) -- Creating a list of types local MyListComponent = Component ({ Name = Type ( \"string\" ), Age = Type ( \"number\" ), })","title":"Creating a Component"},{"location":"GetStarted/Data/#creating-an-entity","text":"Components are just patters for creating data. With entities you can create data. local Entity = River . Entity local MyEntity = Entity ({ MyComponent = MyComponent ( \"Hello World\" ), MyListComponent = MyListComponent ({ Name = \"John\" , Age = 32 , }), }) And thats it! You can now define and create data!","title":"Creating an Entity"},{"location":"GetStarted/Example/","text":"Example Now that you have learned how to use the API, you can use it to create your own systems! Here we have to systems, one for updating the position of entities, and the other for printing the position of the entities. local River = require ( game . ReplicatedStorage . River ) local System = River . System local Query = River . Query local Component = River . Component local Type = River . Type local Entity = River . Entity local World = River . World local Position = Component ( Type ( \"Vector3\" )) local MyEntity = Entity ({ Position = Position ( Vector3 . new ( 0 , 0 , 0 )) }) local QueryPosition = Query ( Position ) local UpdatePosition = System ( function ( entities ) for _ , entity in pairs ( entities ) do entity . Position += Vector3 . new ( 0 , 0 , 1 ) end end ) local PrintPosition = System ( function ( entities ) for _ , entity in pairs ( entities ) do print ( entity . Position ) end end ) UpdatePosition : add ( QueryPosition ) PrintPosition : add ( QueryPosition ) local world = World () world : add ( UpdatePosition , \"update\" ) world : add ( PrintPosition , \"update\" ) world : start ()","title":"Example"},{"location":"GetStarted/Example/#example","text":"Now that you have learned how to use the API, you can use it to create your own systems! Here we have to systems, one for updating the position of entities, and the other for printing the position of the entities. local River = require ( game . ReplicatedStorage . River ) local System = River . System local Query = River . Query local Component = River . Component local Type = River . Type local Entity = River . Entity local World = River . World local Position = Component ( Type ( \"Vector3\" )) local MyEntity = Entity ({ Position = Position ( Vector3 . new ( 0 , 0 , 0 )) }) local QueryPosition = Query ( Position ) local UpdatePosition = System ( function ( entities ) for _ , entity in pairs ( entities ) do entity . Position += Vector3 . new ( 0 , 0 , 1 ) end end ) local PrintPosition = System ( function ( entities ) for _ , entity in pairs ( entities ) do print ( entity . Position ) end end ) UpdatePosition : add ( QueryPosition ) PrintPosition : add ( QueryPosition ) local world = World () world : add ( UpdatePosition , \"update\" ) world : add ( PrintPosition , \"update\" ) world : start ()","title":"Example"},{"location":"GetStarted/Systems/","text":"Calling Systems Whenever you want to change any data on your entities in your game, you will need systems. A systems is just a function with queries as arguments. But, theres something missing! How do we get the data? Using Queries. Queries are a way to get all the entities with a certain Component or Tag. Creating a Query Query is just a list or a single Component or Tag. The query will get all the entities associated with it. Using Queries When creating a query its a good idea to use the same query systems that need them. Lets say if that you have two systems, UpdatePositon and PrintPositon . Then i should only create one query for both. local Query = River . Query local Component = River . Component local Tag = River . Tag local Entity = River . Entity local MyComponent = Component ( Type ( \"string\" )) local MyTag = Tag ( \"MyTag\" ) -- Create som data that can be gotten local MyEntity = Entity ({ MyComponent = MyComponent ( \"Hello World\" ), MyTag = MyTag , }) -- Then to get the data we use query -- Either with a component or a tag, or both. local MyQuery = Query ( MyComponent ) -- Same as local MyQuery = Query ( MyTag ) -- Or do it like this local MyQuery = Query ({ MyComponent = MyComponent , MyTag = MyTag , }) Creating a System Systems are just functions with queries as arguments. -- We defined all the data above local MyQuery = Query ( MyComponent ) local MySystem = System ( function ( query ) -- Note! We don't index the query! for _ , entity in pairs ( queries ) do print ( entity . MyComponent ) end end ) -- If you have a query with multiple components, you can use a table local MyQuery = Query ({ MyComponent = MyComponent , MyTag = MyTag , }) local MySystem = System ( function ( query ) -- Note: We DO index the query! for _ , entity in pairs ( queries . MyQuery ) do print ( entity . MyComponent ) end end ) Adding Queries Before the system can run, you will need to add the queries to the system. You do this with the :add method. local MySystem = System ( function ( query ) for _ , entity in pairs ( queries ) do print ( entity . MyComponent ) end end ) MySystem : add ( MyQuery ) Calling a System Theres two ways of calling a system either with the :call method, or the World object. Lets start with the :call method. -- MySystem is defined above MySystem : call () -- Its that easy Lets try it with the World object. When adding a system to a world, you will need to also pass when it should be called. Theres 3 options: update , start and stop . (They are self explanatory) -- MySystem is defined above local World = River . World local MyWorld = World () -- This system will be called every frame world : add ( MySystem , \"update\" ) -- Remember to start the world MyWorld : start () -- You can also stop it MyWorld : stop ()","title":"Systems"},{"location":"GetStarted/Systems/#calling-systems","text":"Whenever you want to change any data on your entities in your game, you will need systems. A systems is just a function with queries as arguments. But, theres something missing! How do we get the data? Using Queries. Queries are a way to get all the entities with a certain Component or Tag.","title":"Calling Systems"},{"location":"GetStarted/Systems/#creating-a-query","text":"Query is just a list or a single Component or Tag. The query will get all the entities associated with it. Using Queries When creating a query its a good idea to use the same query systems that need them. Lets say if that you have two systems, UpdatePositon and PrintPositon . Then i should only create one query for both. local Query = River . Query local Component = River . Component local Tag = River . Tag local Entity = River . Entity local MyComponent = Component ( Type ( \"string\" )) local MyTag = Tag ( \"MyTag\" ) -- Create som data that can be gotten local MyEntity = Entity ({ MyComponent = MyComponent ( \"Hello World\" ), MyTag = MyTag , }) -- Then to get the data we use query -- Either with a component or a tag, or both. local MyQuery = Query ( MyComponent ) -- Same as local MyQuery = Query ( MyTag ) -- Or do it like this local MyQuery = Query ({ MyComponent = MyComponent , MyTag = MyTag , })","title":"Creating a Query"},{"location":"GetStarted/Systems/#creating-a-system","text":"Systems are just functions with queries as arguments. -- We defined all the data above local MyQuery = Query ( MyComponent ) local MySystem = System ( function ( query ) -- Note! We don't index the query! for _ , entity in pairs ( queries ) do print ( entity . MyComponent ) end end ) -- If you have a query with multiple components, you can use a table local MyQuery = Query ({ MyComponent = MyComponent , MyTag = MyTag , }) local MySystem = System ( function ( query ) -- Note: We DO index the query! for _ , entity in pairs ( queries . MyQuery ) do print ( entity . MyComponent ) end end )","title":"Creating a System"},{"location":"GetStarted/Systems/#adding-queries","text":"Before the system can run, you will need to add the queries to the system. You do this with the :add method. local MySystem = System ( function ( query ) for _ , entity in pairs ( queries ) do print ( entity . MyComponent ) end end ) MySystem : add ( MyQuery )","title":"Adding Queries"},{"location":"GetStarted/Systems/#calling-a-system","text":"Theres two ways of calling a system either with the :call method, or the World object. Lets start with the :call method. -- MySystem is defined above MySystem : call () -- Its that easy Lets try it with the World object. When adding a system to a world, you will need to also pass when it should be called. Theres 3 options: update , start and stop . (They are self explanatory) -- MySystem is defined above local World = River . World local MyWorld = World () -- This system will be called every frame world : add ( MySystem , \"update\" ) -- Remember to start the world MyWorld : start () -- You can also stop it MyWorld : stop ()","title":"Calling a System"}]}